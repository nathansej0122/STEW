# COMMANDS — STEW Command Reference

This document is a **reference**, not a tutorial.

It explains every `h:*` command provided by **STEW**, what it does, and when you should (and should not) use it.

If you are new, read **CONCEPTS.md** and **GREENFIELD.md** first.

---

## Command Namespace Rules

All STEW commands:
- use the `h:` prefix
- live in `.claude/commands/h/`
- are **read-only by default**

STEW commands never:
- execute GSD automatically
- modify project code
- override governance

If a command would cause side effects, it will say so explicitly.

---

## h:status

### Purpose

Displays the **current coordination state** across all tools.

### Gate 0: Planning Contract (REQUIRED)

The planning contract (`.planning/STATE.md` + `.planning/.continue-here.md`) is **required**.
If missing, `h:status` blocks with explicit remediation steps.

### CLEO (Optional)

CLEO is **optional**. If `CLEO_PROJECT_DIR` is not set, `h:status` reports "CLEO: Not configured"
without blocking. The harness will never recommend running `cleo init` inside the project repository.

### What it reads
- Planning contract (required)
- Planning focus from .continue-here.md
- git working tree status
- AI-OPS documents (optional)
- CLEO focus (optional, from `$CLEO_PROJECT_DIR`)

### What it never does
- modify files
- change focus
- execute tools
- recommend `cleo init` in the project repo

### When to use
- at the start of a session
- when routing blocks
- to sanity-check state

---

## h:bootstrap

### Purpose

Creates the **required planning contract files** if they do not exist.

### What it does

- Creates `.planning/` directory if missing
- Creates `.planning/STATE.md` with minimal template if missing
- Creates `.planning/.continue-here.md` with minimal template if missing
- Reports what was created vs skipped
- Reminds user to edit placeholder values

### What it does *not* do

- Overwrite existing files (safe to run multiple times)
- Auto-run (must be explicitly invoked by user)

### When to use

- When `h:status` blocks due to missing planning contract
- When starting a new project and you want STEW to create the files for you

### Templates created

**`.planning/STATE.md`:**
```
Current Work:
  Pointer: <path to current plan doc or phase directory>
  Status: <one-line status>

Next Action:
  <one-line next step>
```

**`.planning/.continue-here.md`:**
```
Current pointer: <path to plan doc to resume>
Why: <one-line context>
Next action: <one-line next step>
```

---

## h:sync-planning

### Purpose

Auto-populates `.planning/.continue-here.md` from `.planning/STATE.md`.

Eliminates manual editing of `.continue-here.md` by deriving values from repo-authored state.

### What it does

- Requires `.planning/STATE.md` (blocks if missing)
- Extracts pointer from STATE.md (`Resume file:`, `Pointer:`, or `Phase Directory:`)
- Extracts status/why from `Status:` line
- Extracts next action from `Next Action:` line
- Writes `.planning/.continue-here.md` with derived values

### Extraction Logic

**CURRENT_POINTER** (priority order):
1. `Resume file: <path>`
2. `Pointer: <path>`
3. `Phase Directory: <dir>` - resolves to `<dir>/PLAN.md` or first `*-PLAN.md`

**WHY**: From `Status:` line, or fallback: "Derived from STATE.md current phase pointer"

**NEXT_ACTION**: From `Next Action:` line, or fallback: "Continue from current plan file"

### Overwrite Policy

| Condition | Behavior | Result |
|-----------|----------|--------|
| File does not exist | Create | Written |
| File contains placeholders (`<path to`, `<one-line`, `TODO`) | Overwrite | Written |
| File has `# Generated by h:sync-planning` header | Overwrite if content differs | Written or Already up-to-date |
| User-edited file (no marker), content differs | Overwrite with marker line | Overwritten |
| Content matches STATE.md | No change | Already up-to-date |

The command is idempotent and safe to run multiple times.

### When to use

- After editing `.planning/STATE.md`
- After `h:bootstrap` creates template files
- When `h:status` shows placeholder content in `.continue-here.md`

---

## h:focus

### Purpose

Displays the **current planning focus** from the planning contract.

### What it does
- Reads current pointer from `.continue-here.md`
- Reads state from `STATE.md`
- Shows the recommended file to open (where work should resume)

### What it does *not* do
- Create or modify planning files
- Require CLEO (CLEO is optional)

### Why it exists

STEW treats planning focus as the single source of truth. The `.continue-here.md` file
determines where work should resume.

---

## h:route

### Purpose

This is the **core STEW command**.

It determines the **single next allowed action** based on current state.

### What it does
1. Verifies planning contract (Gate 0 - REQUIRED)
2. Reads planning focus from .continue-here.md
3. Checks AI-OPS (optional)
4. Determines current phase
5. Detects plans
6. Ensures classification is persisted (to HARNESS_STATE.json)
7. Recommends exactly one next command

### What it never does
- execute GSD
- run ECC
- invoke RALPH
- require CLEO (CLEO is optional)

### Output guarantees
- deterministic
- repeatable
- inspectable

If `h:route` output changes, state has changed.

---

## h:_classify (Internal)

### Purpose

Performs **one-time work classification** for a plan.

### Visibility

- **Not user-callable**
- Invoked only by `h:route`

### What it does
- determines work type and scope
- decides whether automation is allowed
- decides whether review is useful
- persists the result

### Why it matters

This is the mechanism that prevents repeated AI reasoning and token waste.

---

## h:ecc-code-review

### Purpose

Runs a **read-only code review** using ECC agent specifications.

### Preconditions
- recent code changes exist
- STEW recommends or allows review

### What it reads
- ECC agent spec from native tool directory
- git diffs
- AI-OPS constraints

### What it never does
- modify code
- apply fixes

---

## h:ecc-security-review

### Purpose

Runs a **security-focused** review using ECC.

### When it appears
- security-sensitive changes
- high-risk zones defined in AI-OPS

This command may not always be suggested.

---

## h:ecc-doc-update

### Purpose

Identifies documentation gaps or drift caused by recent changes.

### Typical use
- after refactors
- after structural changes

---

## h:ecc-refactor-clean

### Purpose

Identifies refactoring opportunities **without executing them**.

### Important

This command **suggests** refactors. It never performs them.

---

## h:ralph-init

### Purpose

Creates a **RALPH bundle** for a specific task.

### What it does
- creates `.planning/ralph/<slug>/`
- writes PRD and run metadata

### Preconditions
- STEW explicitly allows automation

If automation is forbidden, this command should not be used.

---

## h:ralph-run

### Purpose

Prepares and validates a RALPH execution.

### What it does
- validates clean working tree
- validates bundle integrity
- prints the exact command to run

### What it does *not* do
- directly run RALPH inline

Execution always requires explicit user confirmation.

---

## h:commit

### Purpose

Commits changes using **explicit per-file staging** with mode-based allowlists.

This is the GSD-style commit strategy: frequent commits are OK, but only for verified outcomes.

### What it does

- Validates branch (refuses main/master by default)
- Detects changed files via `git status --porcelain`
- Validates files against mode-specific allowlist
- Detects placeholder text in planning files
- Stages files individually (NEVER `git add .` or `-A`)
- Commits with conventional commit message format

### What it never does

- Use `git add .` or `git add -A`
- Commit `.gitignore`
- Commit to main/master without explicit override
- Commit placeholder scaffolding without explicit override
- Auto-commit (dry-run by default)

### Modes

| Mode | Allowed Files |
|------|---------------|
| `planning` | `.planning/**` (with placeholder check) |
| `harness` | `.claude/commands/h/**`, `scripts/h/**` |
| `docs` | `README.md`, `COMMANDS.md`, `INSTALL.md`, `BROWNFIELD.md`, `GREENFIELD.md`, `ARCHITECTURE.md`, `CONCEPTS.md`, `GOVERNANCE.md` |
| `auto` | Infers from changed files; refuses if mixed |

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `STEW_COMMIT_MSG` | (required) | Commit message |
| `STEW_COMMIT_TYPE` | `chore` | Conventional type (feat, fix, chore, docs) |
| `STEW_COMMIT_SCOPE` | `harness` | Scope for commit message |
| `STEW_COMMIT_MODE` | `auto` | One of: planning, harness, docs, auto |
| `STEW_COMMIT_YES` | `0` | If 1, actually commit; if 0, dry-run |
| `STEW_COMMIT_ALLOW_PLACEHOLDERS` | `0` | If 1, allow placeholder text |
| `STEW_COMMIT_ALLOW_MAIN` | `0` | If 1, allow commits to main/master |

### Examples

**Planning mode:**
```bash
STEW_COMMIT_MODE=planning \
STEW_COMMIT_MSG="initialize planning contract" \
STEW_COMMIT_YES=1 \
h:commit
```

**Harness mode:**
```bash
STEW_COMMIT_MODE=harness \
STEW_COMMIT_TYPE=feat \
STEW_COMMIT_MSG="add bootstrap command" \
STEW_COMMIT_YES=1 \
h:commit
```

### When to use

- After editing planning files (`.planning/*`)
- After updating harness commands (`.claude/commands/h/*`)
- After updating documentation
- When you want explicit control over what gets committed

---

## Design Guarantees

Across all commands:
- one command → one responsibility
- no hidden side effects
- no implicit execution

If behavior feels surprising, state is inconsistent.

---

## Next Document

- **GOVERNANCE.md** — how classification and gating decisions are made


---

## Plans, Summaries, and Task Memory (Why This Is Not Redundant)

At first glance, STEW + GSD + CLEO can look like overlapping systems:
- plans and summaries
- state files and task notes
- routing and execution

This is intentional separation, not duplication.

The system works because **each artifact answers a different question at a different time**.

---

### PLAN.md — Intent ("What should happen?")

Created by the user via GSD planning commands.

Used by:
- GSD to know what to execute
- STEW to classify and govern
- humans to inspect intent *before* execution

Plans are explicit, forward-looking, and contractual.

They exist so intent is written once instead of inferred repeatedly.

---

### SUMMARY.md — Outcome ("What actually happened?")

Created by GSD during or after execution.

Used for:
- audit and review
- progress reporting
- historical accountability

Summaries are descriptive and backward-looking.

They are **not** used for routing or governance.

Routing based on narrative history would require repeated interpretation, which this system avoids by design.

---

### STATE.md — Position ("Where are we right now?")

Maintained by GSD.

Used by:
- GSD for phase progression
- STEW for routing eligibility

STATE.md encodes position, not meaning.

---

### CLEO Task Notes — Decisions ("What has already been decided?")

Stored in CLEO task metadata.

Used by:
- STEW to cache classification and governance decisions
- humans to retain rationale across sessions

These notes prevent the system from re-evaluating safety, scope, and automation decisions.

---

### Why These Are Separate

If these concerns were collapsed:
- plans would need to include history
- summaries would need to include intent
- routing would depend on prose

That would force continuous reinterpretation.

Instead:
- intent is written once
- judgment is cached once
- history is recorded once

Each artifact may be read many times, but **reasoned about only once**.

---

### Efficiency and Scale

What looks like redundancy is **load-bearing separation**.

This structure eliminates:
- repeated safety analysis
- repeated scope inference
- repeated intent reconstruction

As projects grow, this separation is what keeps token usage predictable and behavior stable.

---

### Analogy

- PLAN.md is a contract
- SUMMARY.md is a receipt
- STATE.md is your current location
- CLEO notes are margin annotations
- STEW enforces the rules of the contract
- GSD builds what the contract specifies

You do not drive using receipts.

---

## Regression Test: CLEO External State Handling

To verify that the harness correctly handles CLEO external state, test these scenarios:

### Scenario 1: No CLEO_PROJECT_DIR set

```bash
unset CLEO_PROJECT_DIR
h:status
```

**Expected output:**
- CLEO status line shows: `Not configured (set CLEO_PROJECT_DIR)`
- No JSON error blobs (e.g., `E_NOT_INITIALIZED`)
- No recommendation to run `cleo init` in the project repo

### Scenario 2: CLEO_PROJECT_DIR set but uninitialized

```bash
export CLEO_PROJECT_DIR=/tmp/test-cleo-uninitialized
mkdir -p "$CLEO_PROJECT_DIR"
h:status
```

**Expected output:**
- CLEO status line shows: `Project state not initialized in $CLEO_PROJECT_DIR`
- No JSON error blobs
- May recommend initializing CLEO *in the external directory*, NOT in the project repo

### Scenario 3: CLEO_PROJECT_DIR set and initialized

```bash
export CLEO_PROJECT_DIR=/tmp/test-cleo-initialized
mkdir -p "$CLEO_PROJECT_DIR"
(cd "$CLEO_PROJECT_DIR" && cleo init)
(cd "$CLEO_PROJECT_DIR" && cleo add "Test task" && cleo focus set T001)
h:status
```

**Expected output:**
- CLEO status line shows: `T001 - Test task`
- Recommendations proceed normally (e.g., `h:route`)

### Verification Checklist

- [ ] `h:status` never emits raw JSON error objects
- [ ] `h:status` never recommends `cleo init` inside the project repo
- [ ] `h:focus` handles all three scenarios cleanly
- [ ] `h:route` blocks with clear messages when CLEO is not configured

